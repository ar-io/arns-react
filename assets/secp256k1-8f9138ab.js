import{d0 as we,d1 as me,d2 as Ft,d3 as bt}from"./index-151c117e.js";(function(){try{var t=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},n=new Error().stack;n&&(t._sentryDebugIds=t._sentryDebugIds||{},t._sentryDebugIds[n]="77ed74de-6f5a-412c-6e7a-24169fdc272a",t._sentryDebugIdIdentifier="sentry-dbid-77ed74de-6f5a-412c-6e7a-24169fdc272a")}catch{}})();/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const te=BigInt(0),vt=BigInt(1),be=BigInt(2);function ft(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function W(t){if(!ft(t))throw new Error("Uint8Array expected")}const ye=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function dt(t){W(t);let n="";for(let e=0;e<t.length;e++)n+=ye[t[e]];return n}function ee(t){const n=t.toString(16);return n.length&1?`0${n}`:n}function Zt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}const X={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function jt(t){if(t>=X._0&&t<=X._9)return t-X._0;if(t>=X._A&&t<=X._F)return t-(X._A-10);if(t>=X._a&&t<=X._f)return t-(X._a-10)}function ht(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length,e=n/2;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let o=0,i=0;o<e;o++,i+=2){const u=jt(t.charCodeAt(i)),c=jt(t.charCodeAt(i+1));if(u===void 0||c===void 0){const s=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+i)}r[o]=u*16+c}return r}function k(t){return Zt(dt(t))}function Ct(t){return W(t),Zt(dt(Uint8Array.from(t).reverse()))}function rt(t,n){return ht(t.toString(16).padStart(n*2,"0"))}function Vt(t,n){return rt(t,n).reverse()}function Ee(t){return ht(ee(t))}function V(t,n,e){let r;if(typeof n=="string")try{r=ht(n)}catch(i){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${i}`)}else if(ft(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(`${t} expected ${e} bytes, got ${o}`);return r}function Y(...t){let n=0;for(let r=0;r<t.length;r++){const o=t[r];W(o),n+=o.length}const e=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){const i=t[r];e.set(i,o),o+=i.length}return e}function pe(t,n){if(t.length!==n.length)return!1;let e=0;for(let r=0;r<t.length;r++)e|=t[r]^n[r];return e===0}function xt(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Be(t){let n;for(n=0;t>te;t>>=vt,n+=1);return n}function ve(t,n){return t>>BigInt(n)&vt}function xe(t,n,e){return t|(e?vt:te)<<BigInt(n)}const Lt=t=>(be<<BigInt(t-1))-vt,qt=t=>new Uint8Array(t),Dt=t=>Uint8Array.from(t);function ne(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=qt(t),o=qt(t),i=0;const u=()=>{r.fill(1),o.fill(0),i=0},c=(...l)=>e(o,r,...l),s=(l=qt())=>{o=c(Dt([0]),l),r=c(),l.length!==0&&(o=c(Dt([1]),l),r=c())},f=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const _=[];for(;l<n;){r=c();const v=r.slice();_.push(v),l+=r.length}return Y(..._)};return(l,_)=>{u(),s(l);let v;for(;!(v=_(f()));)s();return u(),v}}const Se={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||ft(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function gt(t,n,e={}){const r=(o,i,u)=>{const c=Se[i];if(typeof c!="function")throw new Error(`Invalid validator "${i}", expected function`);const s=t[o];if(!(u&&s===void 0)&&!c(s,t))throw new Error(`Invalid param ${String(o)}=${s} (${typeof s}), expected ${i}`)};for(const[o,i]of Object.entries(n))r(o,i,!1);for(const[o,i]of Object.entries(e))r(o,i,!0);return t}const Ie=Object.freeze(Object.defineProperty({__proto__:null,abytes:W,bitGet:ve,bitLen:Be,bitMask:Lt,bitSet:xe,bytesToHex:dt,bytesToNumberBE:k,bytesToNumberLE:Ct,concatBytes:Y,createHmacDrbg:ne,ensureBytes:V,equalBytes:pe,hexToBytes:ht,hexToNumber:Zt,isBytes:ft,numberToBytesBE:rt,numberToBytesLE:Vt,numberToHexUnpadded:ee,numberToVarBytesBE:Ee,utf8ToBytes:xt,validateObject:gt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const C=BigInt(0),$=BigInt(1),st=BigInt(2),_e=BigInt(3),Tt=BigInt(4),Mt=BigInt(5),Gt=BigInt(8);BigInt(9);BigInt(16);function Z(t,n){const e=t%n;return e>=C?e:n+e}function Ae(t,n,e){if(e<=C||n<C)throw new Error("Expected power/modulo > 0");if(e===$)return C;let r=$;for(;n>C;)n&$&&(r=r*t%e),t=t*t%e,n>>=$;return r}function j(t,n,e){let r=t;for(;n-- >C;)r*=r,r%=e;return r}function Rt(t,n){if(t===C||n<=C)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=Z(t,n),r=n,o=C,i=$;for(;e!==C;){const c=r/e,s=r%e,f=o-i*c;r=e,e=s,o=i,i=f}if(r!==$)throw new Error("invert: does not exist");return Z(o,n)}function qe(t){const n=(t-$)/st;let e,r,o;for(e=t-$,r=0;e%st===C;e/=st,r++);for(o=st;o<t&&Ae(o,n,t)!==t-$;o++);if(r===1){const u=(t+$)/Tt;return function(s,f){const w=s.pow(f,u);if(!s.eql(s.sqr(w),f))throw new Error("Cannot find square root");return w}}const i=(e+$)/st;return function(c,s){if(c.pow(s,n)===c.neg(c.ONE))throw new Error("Cannot find square root");let f=r,w=c.pow(c.mul(c.ONE,o),e),l=c.pow(s,i),_=c.pow(s,e);for(;!c.eql(_,c.ONE);){if(c.eql(_,c.ZERO))return c.ZERO;let v=1;for(let a=c.sqr(_);v<f&&!c.eql(a,c.ONE);v++)a=c.sqr(a);const y=c.pow(w,$<<BigInt(f-v-1));w=c.sqr(y),l=c.mul(l,y),_=c.mul(_,w),f=v}return l}}function Oe(t){if(t%Tt===_e){const n=(t+$)/Tt;return function(r,o){const i=r.pow(o,n);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(t%Gt===Mt){const n=(t-Mt)/Gt;return function(r,o){const i=r.mul(o,st),u=r.pow(i,n),c=r.mul(o,u),s=r.mul(r.mul(c,st),u),f=r.mul(c,r.sub(s,r.ONE));if(!r.eql(r.sqr(f),o))throw new Error("Cannot find square root");return f}}return qe(t)}const Ne=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function re(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Ne.reduce((r,o)=>(r[o]="function",r),n);return gt(t,e)}function Te(t,n,e){if(e<C)throw new Error("Expected power > 0");if(e===C)return t.ONE;if(e===$)return n;let r=t.ONE,o=n;for(;e>C;)e&$&&(r=t.mul(r,o)),o=t.sqr(o),e>>=$;return r}function Re(t,n){const e=new Array(n.length),r=n.reduce((i,u,c)=>t.is0(u)?i:(e[c]=i,t.mul(i,u)),t.ONE),o=t.inv(r);return n.reduceRight((i,u,c)=>t.is0(u)?i:(e[c]=t.mul(i,e[c]),t.mul(i,u)),o),e}function oe(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function $e(t,n,e=!1,r={}){if(t<=C)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:i}=oe(t,n);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const u=Oe(t),c=Object.freeze({ORDER:t,BITS:o,BYTES:i,MASK:Lt(o),ZERO:C,ONE:$,create:s=>Z(s,t),isValid:s=>{if(typeof s!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof s}`);return C<=s&&s<t},is0:s=>s===C,isOdd:s=>(s&$)===$,neg:s=>Z(-s,t),eql:(s,f)=>s===f,sqr:s=>Z(s*s,t),add:(s,f)=>Z(s+f,t),sub:(s,f)=>Z(s-f,t),mul:(s,f)=>Z(s*f,t),pow:(s,f)=>Te(c,s,f),div:(s,f)=>Z(s*Rt(f,t),t),sqrN:s=>s*s,addN:(s,f)=>s+f,subN:(s,f)=>s-f,mulN:(s,f)=>s*f,inv:s=>Rt(s,t),sqrt:r.sqrt||(s=>u(c,s)),invertBatch:s=>Re(c,s),cmov:(s,f,w)=>w?f:s,toBytes:s=>e?Vt(s,i):rt(s,i),fromBytes:s=>{if(s.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${s.length}`);return e?Ct(s):k(s)}});return Object.freeze(c)}function ie(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function se(t){const n=ie(t);return n+Math.ceil(n/2)}function Ue(t,n,e=!1){const r=t.length,o=ie(n),i=se(n);if(r<16||r<i||r>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${r}`);const u=e?k(t):Ct(t),c=Z(u,n-$)+$;return e?Vt(c,o):rt(c,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ze=BigInt(0),Ot=BigInt(1);function Ce(t,n){const e=(o,i)=>{const u=i.negate();return o?u:i},r=o=>{const i=Math.ceil(n/o)+1,u=2**(o-1);return{windows:i,windowSize:u}};return{constTimeNegate:e,unsafeLadder(o,i){let u=t.ZERO,c=o;for(;i>Ze;)i&Ot&&(u=u.add(c)),c=c.double(),i>>=Ot;return u},precomputeWindow(o,i){const{windows:u,windowSize:c}=r(i),s=[];let f=o,w=f;for(let l=0;l<u;l++){w=f,s.push(w);for(let _=1;_<c;_++)w=w.add(f),s.push(w);f=w.double()}return s},wNAF(o,i,u){const{windows:c,windowSize:s}=r(o);let f=t.ZERO,w=t.BASE;const l=BigInt(2**o-1),_=2**o,v=BigInt(o);for(let y=0;y<c;y++){const a=y*s;let h=Number(u&l);u>>=v,h>s&&(h-=_,u+=Ot);const d=a,m=a+Math.abs(h)-1,E=y%2!==0,x=h<0;h===0?w=w.add(e(E,i[d])):f=f.add(e(x,i[m]))}return{p:f,f:w}},wNAFCached(o,i,u,c){const s=o._WINDOW_SIZE||1;let f=i.get(o);return f||(f=this.precomputeWindow(o,s),s!==1&&i.set(o,c(f))),this.wNAF(s,f,u)}}}function ce(t){return re(t.Fp),gt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...oe(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ve(t){const n=ce(t);gt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:Le,hexToBytes:ke}=Ie,ct={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(t){const{Err:n}=ct;if(t.length<2||t[0]!==2)throw new n("Invalid signature integer tag");const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:Le(r),l:t.subarray(e+2)}},toSig(t){const{Err:n}=ct,e=typeof t=="string"?ke(t):t;W(e);let r=e.length;if(r<2||e[0]!=48)throw new n("Invalid signature tag");if(e[1]!==r-2)throw new n("Invalid signature: incorrect length");const{d:o,l:i}=ct._parseInt(e.subarray(2)),{d:u,l:c}=ct._parseInt(i);if(c.length)throw new n("Invalid signature: left bytes after parsing");return{r:o,s:u}},hexFromSig(t){const n=f=>Number.parseInt(f[0],16)&8?"00"+f:f,e=f=>{const w=f.toString(16);return w.length&1?`0${w}`:w},r=n(e(t.s)),o=n(e(t.r)),i=r.length/2,u=o.length/2,c=e(i),s=e(u);return`30${e(u+i+4)}02${s}${o}02${c}${r}`}},G=BigInt(0),R=BigInt(1),et=BigInt(2),yt=BigInt(3),Wt=BigInt(4);function Pe(t){const n=Ve(t),{Fp:e}=n,r=n.toBytes||((y,a,h)=>{const d=a.toAffine();return Y(Uint8Array.from([4]),e.toBytes(d.x),e.toBytes(d.y))}),o=n.fromBytes||(y=>{const a=y.subarray(1),h=e.fromBytes(a.subarray(0,e.BYTES)),d=e.fromBytes(a.subarray(e.BYTES,2*e.BYTES));return{x:h,y:d}});function i(y){const{a,b:h}=n,d=e.sqr(y),m=e.mul(d,y);return e.add(e.add(m,e.mul(y,a)),h)}if(!e.eql(e.sqr(n.Gy),i(n.Gx)))throw new Error("bad generator point: equation left != right");function u(y){return typeof y=="bigint"&&G<y&&y<n.n}function c(y){if(!u(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function s(y){const{allowedPrivateKeyLengths:a,nByteLength:h,wrapPrivateKey:d,n:m}=n;if(a&&typeof y!="bigint"){if(ft(y)&&(y=dt(y)),typeof y!="string"||!a.includes(y.length))throw new Error("Invalid key");y=y.padStart(h*2,"0")}let E;try{E=typeof y=="bigint"?y:k(V("private key",y,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof y}`)}return d&&(E=Z(E,m)),c(E),E}const f=new Map;function w(y){if(!(y instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(a,h,d){if(this.px=a,this.py=h,this.pz=d,a==null||!e.isValid(a))throw new Error("x required");if(h==null||!e.isValid(h))throw new Error("y required");if(d==null||!e.isValid(d))throw new Error("z required")}static fromAffine(a){const{x:h,y:d}=a||{};if(!a||!e.isValid(h)||!e.isValid(d))throw new Error("invalid affine point");if(a instanceof l)throw new Error("projective point not allowed");const m=E=>e.eql(E,e.ZERO);return m(h)&&m(d)?l.ZERO:new l(h,d,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const h=e.invertBatch(a.map(d=>d.pz));return a.map((d,m)=>d.toAffine(h[m])).map(l.fromAffine)}static fromHex(a){const h=l.fromAffine(o(V("pointHex",a)));return h.assertValidity(),h}static fromPrivateKey(a){return l.BASE.multiply(s(a))}_setWindowSize(a){this._WINDOW_SIZE=a,f.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:a,y:h}=this.toAffine();if(!e.isValid(a)||!e.isValid(h))throw new Error("bad point: x or y not FE");const d=e.sqr(h),m=i(a);if(!e.eql(d,m))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){w(a);const{px:h,py:d,pz:m}=this,{px:E,py:x,pz:I}=a,p=e.eql(e.mul(h,I),e.mul(E,m)),B=e.eql(e.mul(d,I),e.mul(x,m));return p&&B}negate(){return new l(this.px,e.neg(this.py),this.pz)}double(){const{a,b:h}=n,d=e.mul(h,yt),{px:m,py:E,pz:x}=this;let I=e.ZERO,p=e.ZERO,B=e.ZERO,S=e.mul(m,m),L=e.mul(E,E),T=e.mul(x,x),q=e.mul(m,E);return q=e.add(q,q),B=e.mul(m,x),B=e.add(B,B),I=e.mul(a,B),p=e.mul(d,T),p=e.add(I,p),I=e.sub(L,p),p=e.add(L,p),p=e.mul(I,p),I=e.mul(q,I),B=e.mul(d,B),T=e.mul(a,T),q=e.sub(S,T),q=e.mul(a,q),q=e.add(q,B),B=e.add(S,S),S=e.add(B,S),S=e.add(S,T),S=e.mul(S,q),p=e.add(p,S),T=e.mul(E,x),T=e.add(T,T),S=e.mul(T,q),I=e.sub(I,S),B=e.mul(T,L),B=e.add(B,B),B=e.add(B,B),new l(I,p,B)}add(a){w(a);const{px:h,py:d,pz:m}=this,{px:E,py:x,pz:I}=a;let p=e.ZERO,B=e.ZERO,S=e.ZERO;const L=n.a,T=e.mul(n.b,yt);let q=e.mul(h,E),K=e.mul(d,x),H=e.mul(m,I),Q=e.add(h,d),g=e.add(E,x);Q=e.mul(Q,g),g=e.add(q,K),Q=e.sub(Q,g),g=e.add(h,m);let b=e.add(E,I);return g=e.mul(g,b),b=e.add(q,H),g=e.sub(g,b),b=e.add(d,m),p=e.add(x,I),b=e.mul(b,p),p=e.add(K,H),b=e.sub(b,p),S=e.mul(L,g),p=e.mul(T,H),S=e.add(p,S),p=e.sub(K,S),S=e.add(K,S),B=e.mul(p,S),K=e.add(q,q),K=e.add(K,q),H=e.mul(L,H),g=e.mul(T,g),K=e.add(K,H),H=e.sub(q,H),H=e.mul(L,H),g=e.add(g,H),q=e.mul(K,g),B=e.add(B,q),q=e.mul(b,g),p=e.mul(Q,p),p=e.sub(p,q),q=e.mul(Q,K),S=e.mul(b,S),S=e.add(S,q),new l(p,B,S)}subtract(a){return this.add(a.negate())}is0(){return this.equals(l.ZERO)}wNAF(a){return v.wNAFCached(this,f,a,h=>{const d=e.invertBatch(h.map(m=>m.pz));return h.map((m,E)=>m.toAffine(d[E])).map(l.fromAffine)})}multiplyUnsafe(a){const h=l.ZERO;if(a===G)return h;if(c(a),a===R)return this;const{endo:d}=n;if(!d)return v.unsafeLadder(this,a);let{k1neg:m,k1:E,k2neg:x,k2:I}=d.splitScalar(a),p=h,B=h,S=this;for(;E>G||I>G;)E&R&&(p=p.add(S)),I&R&&(B=B.add(S)),S=S.double(),E>>=R,I>>=R;return m&&(p=p.negate()),x&&(B=B.negate()),B=new l(e.mul(B.px,d.beta),B.py,B.pz),p.add(B)}multiply(a){c(a);let h=a,d,m;const{endo:E}=n;if(E){const{k1neg:x,k1:I,k2neg:p,k2:B}=E.splitScalar(h);let{p:S,f:L}=this.wNAF(I),{p:T,f:q}=this.wNAF(B);S=v.constTimeNegate(x,S),T=v.constTimeNegate(p,T),T=new l(e.mul(T.px,E.beta),T.py,T.pz),d=S.add(T),m=L.add(q)}else{const{p:x,f:I}=this.wNAF(h);d=x,m=I}return l.normalizeZ([d,m])[0]}multiplyAndAddUnsafe(a,h,d){const m=l.BASE,E=(I,p)=>p===G||p===R||!I.equals(m)?I.multiplyUnsafe(p):I.multiply(p),x=E(this,h).add(E(a,d));return x.is0()?void 0:x}toAffine(a){const{px:h,py:d,pz:m}=this,E=this.is0();a==null&&(a=E?e.ONE:e.inv(m));const x=e.mul(h,a),I=e.mul(d,a),p=e.mul(m,a);if(E)return{x:e.ZERO,y:e.ZERO};if(!e.eql(p,e.ONE))throw new Error("invZ was invalid");return{x,y:I}}isTorsionFree(){const{h:a,isTorsionFree:h}=n;if(a===R)return!0;if(h)return h(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:h}=n;return a===R?this:h?h(l,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return this.assertValidity(),r(l,this,a)}toHex(a=!0){return dt(this.toRawBytes(a))}}l.BASE=new l(n.Gx,n.Gy,e.ONE),l.ZERO=new l(e.ZERO,e.ONE,e.ZERO);const _=n.nBitLength,v=Ce(l,n.endo?Math.ceil(_/2):_);return{CURVE:n,ProjectivePoint:l,normPrivateKeyToScalar:s,weierstrassEquation:i,isWithinCurveOrder:u}}function ze(t){const n=ce(t);return gt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Ke(t){const n=ze(t),{Fp:e,n:r}=n,o=e.BYTES+1,i=2*e.BYTES+1;function u(g){return G<g&&g<e.ORDER}function c(g){return Z(g,r)}function s(g){return Rt(g,r)}const{ProjectivePoint:f,normPrivateKeyToScalar:w,weierstrassEquation:l,isWithinCurveOrder:_}=Pe({...n,toBytes(g,b,A){const N=b.toAffine(),O=e.toBytes(N.x),U=Y;return A?U(Uint8Array.from([b.hasEvenY()?2:3]),O):U(Uint8Array.from([4]),O,e.toBytes(N.y))},fromBytes(g){const b=g.length,A=g[0],N=g.subarray(1);if(b===o&&(A===2||A===3)){const O=k(N);if(!u(O))throw new Error("Point is not on curve");const U=l(O);let P;try{P=e.sqrt(U)}catch(D){const F=D instanceof Error?": "+D.message:"";throw new Error("Point is not on curve"+F)}const z=(P&R)===R;return(A&1)===1!==z&&(P=e.neg(P)),{x:O,y:P}}else if(b===i&&A===4){const O=e.fromBytes(N.subarray(0,e.BYTES)),U=e.fromBytes(N.subarray(e.BYTES,2*e.BYTES));return{x:O,y:U}}else throw new Error(`Point of length ${b} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`)}}),v=g=>dt(rt(g,n.nByteLength));function y(g){const b=r>>R;return g>b}function a(g){return y(g)?c(-g):g}const h=(g,b,A)=>k(g.slice(b,A));class d{constructor(b,A,N){this.r=b,this.s=A,this.recovery=N,this.assertValidity()}static fromCompact(b){const A=n.nByteLength;return b=V("compactSignature",b,A*2),new d(h(b,0,A),h(b,A,2*A))}static fromDER(b){const{r:A,s:N}=ct.toSig(V("DER",b));return new d(A,N)}assertValidity(){if(!_(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!_(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(b){return new d(this.r,this.s,b)}recoverPublicKey(b){const{r:A,s:N,recovery:O}=this,U=B(V("msgHash",b));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const P=O===2||O===3?A+n.n:A;if(P>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const z=O&1?"03":"02",J=f.fromHex(z+v(P)),D=s(P),F=c(-U*D),wt=c(N*D),tt=f.BASE.multiplyAndAddUnsafe(J,F,wt);if(!tt)throw new Error("point at infinify");return tt.assertValidity(),tt}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return ht(this.toDERHex())}toDERHex(){return ct.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ht(this.toCompactHex())}toCompactHex(){return v(this.r)+v(this.s)}}const m={isValidPrivateKey(g){try{return w(g),!0}catch{return!1}},normPrivateKeyToScalar:w,randomPrivateKey:()=>{const g=se(n.n);return Ue(n.randomBytes(g),n.n)},precompute(g=8,b=f.BASE){return b._setWindowSize(g),b.multiply(BigInt(3)),b}};function E(g,b=!0){return f.fromPrivateKey(g).toRawBytes(b)}function x(g){const b=ft(g),A=typeof g=="string",N=(b||A)&&g.length;return b?N===o||N===i:A?N===2*o||N===2*i:g instanceof f}function I(g,b,A=!0){if(x(g))throw new Error("first arg must be private key");if(!x(b))throw new Error("second arg must be public key");return f.fromHex(b).multiply(w(g)).toRawBytes(A)}const p=n.bits2int||function(g){const b=k(g),A=g.length*8-n.nBitLength;return A>0?b>>BigInt(A):b},B=n.bits2int_modN||function(g){return c(p(g))},S=Lt(n.nBitLength);function L(g){if(typeof g!="bigint")throw new Error("bigint expected");if(!(G<=g&&g<S))throw new Error(`bigint expected < 2^${n.nBitLength}`);return rt(g,n.nByteLength)}function T(g,b,A=q){if(["recovered","canonical"].some(it=>it in A))throw new Error("sign() legacy options not supported");const{hash:N,randomBytes:O}=n;let{lowS:U,prehash:P,extraEntropy:z}=A;U==null&&(U=!0),g=V("msgHash",g),P&&(g=V("prehashed msgHash",N(g)));const J=B(g),D=w(b),F=[L(D),L(J)];if(z!=null&&z!==!1){const it=z===!0?O(e.BYTES):z;F.push(V("extraEntropy",it))}const wt=Y(...F),tt=J;function At(it){const at=p(it);if(!_(at))return;const Kt=s(at),ut=f.BASE.multiply(at).toAffine(),M=c(ut.x);if(M===G)return;const lt=c(Kt*c(tt+M*D));if(lt===G)return;let Ht=(ut.x===M?0:2)|Number(ut.y&R),Yt=lt;return U&&y(lt)&&(Yt=a(lt),Ht^=1),new d(M,Yt,Ht)}return{seed:wt,k2sig:At}}const q={lowS:n.lowS,prehash:!1},K={lowS:n.lowS,prehash:!1};function H(g,b,A=q){const{seed:N,k2sig:O}=T(g,b,A),U=n;return ne(U.hash.outputLen,U.nByteLength,U.hmac)(N,O)}f.BASE._setWindowSize(8);function Q(g,b,A,N=K){var ut;const O=g;if(b=V("msgHash",b),A=V("publicKey",A),"strict"in N)throw new Error("options.strict was renamed to lowS");const{lowS:U,prehash:P}=N;let z,J;try{if(typeof O=="string"||ft(O))try{z=d.fromDER(O)}catch(M){if(!(M instanceof ct.Err))throw M;z=d.fromCompact(O)}else if(typeof O=="object"&&typeof O.r=="bigint"&&typeof O.s=="bigint"){const{r:M,s:lt}=O;z=new d(M,lt)}else throw new Error("PARSE");J=f.fromHex(A)}catch(M){if(M.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(U&&z.hasHighS())return!1;P&&(b=n.hash(b));const{r:D,s:F}=z,wt=B(b),tt=s(F),At=c(wt*tt),it=c(D*tt),at=(ut=f.BASE.multiplyAndAddUnsafe(J,At,it))==null?void 0:ut.toAffine();return at?c(at.x)===D:!1}return{CURVE:n,getPublicKey:E,getSharedSecret:I,sign:H,verify:Q,ProjectivePoint:f,Signature:d,utils:m}}function He(t,n){const e=t.ORDER;let r=G;for(let y=e-R;y%et===G;y/=et)r+=R;const o=r,i=et<<o-R-R,u=i*et,c=(e-R)/u,s=(c-R)/et,f=u-R,w=i,l=t.pow(n,c),_=t.pow(n,(c+R)/et);let v=(y,a)=>{let h=l,d=t.pow(a,f),m=t.sqr(d);m=t.mul(m,a);let E=t.mul(y,m);E=t.pow(E,s),E=t.mul(E,d),d=t.mul(E,a),m=t.mul(E,y);let x=t.mul(m,d);E=t.pow(x,w);let I=t.eql(E,t.ONE);d=t.mul(m,_),E=t.mul(x,h),m=t.cmov(d,m,I),x=t.cmov(E,x,I);for(let p=o;p>R;p--){let B=p-et;B=et<<B-R;let S=t.pow(x,B);const L=t.eql(S,t.ONE);d=t.mul(m,h),h=t.mul(h,h),S=t.mul(x,h),m=t.cmov(d,m,L),x=t.cmov(S,x,L)}return{isValid:I,value:m}};if(t.ORDER%Wt===yt){const y=(t.ORDER-yt)/Wt,a=t.sqrt(t.neg(n));v=(h,d)=>{let m=t.sqr(d);const E=t.mul(h,d);m=t.mul(m,E);let x=t.pow(m,y);x=t.mul(x,E);const I=t.mul(x,a),p=t.mul(t.sqr(x),d),B=t.eql(p,h);let S=t.cmov(I,x,B);return{isValid:B,value:S}}}return v}function Ye(t,n){if(re(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=He(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,i,u,c,s,f,w,l;o=t.sqr(r),o=t.mul(o,n.Z),i=t.sqr(o),i=t.add(i,o),u=t.add(i,t.ONE),u=t.mul(u,n.B),c=t.cmov(n.Z,t.neg(i),!t.eql(i,t.ZERO)),c=t.mul(c,n.A),i=t.sqr(u),f=t.sqr(c),s=t.mul(f,n.A),i=t.add(i,s),i=t.mul(i,u),f=t.mul(f,c),s=t.mul(f,n.B),i=t.add(i,s),w=t.mul(o,u);const{isValid:_,value:v}=e(i,f);l=t.mul(o,r),l=t.mul(l,v),w=t.cmov(w,u,_),l=t.cmov(l,v,_);const y=t.isOdd(r)===t.isOdd(l);return l=t.cmov(t.neg(l),l,y),w=t.div(w,c),{x:w,y:l}}}const je=k;function nt(t,n){if(t<0||t>=1<<8*n)throw new Error(`bad I2OSP call: value=${t} length=${n}`);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function De(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function kt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Me(t,n,e,r){W(t),W(n),kt(e),n.length>255&&(n=r(Y(xt("H2C-OVERSIZE-DST-"),n)));const{outputLen:o,blockLen:i}=r,u=Math.ceil(e/o);if(u>255)throw new Error("Invalid xmd length");const c=Y(n,nt(n.length,1)),s=nt(0,i),f=nt(e,2),w=new Array(u),l=r(Y(s,t,f,nt(0,1),c));w[0]=r(Y(l,nt(1,1),c));for(let v=1;v<=u;v++){const y=[De(l,w[v-1]),nt(v+1,1),c];w[v]=r(Y(...y))}return Y(...w).slice(0,e)}function Ge(t,n,e,r,o){if(W(t),W(n),kt(e),n.length>255){const i=Math.ceil(2*r/8);n=o.create({dkLen:i}).update(xt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(nt(e,2)).update(n).update(nt(n.length,1)).digest()}function Xt(t,n,e){gt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:i,hash:u,expand:c,DST:s}=e;W(t),kt(n);const f=typeof s=="string"?xt(s):s,w=r.toString(2).length,l=Math.ceil((w+o)/8),_=n*i*l;let v;if(c==="xmd")v=Me(t,f,_,u);else if(c==="xof")v=Ge(t,f,_,o,u);else if(c==="_internal_pass")v=t;else throw new Error('expand must be "xmd" or "xof"');const y=new Array(n);for(let a=0;a<n;a++){const h=new Array(i);for(let d=0;d<i;d++){const m=l*(d+a*i),E=v.subarray(m,m+l);h[d]=Z(je(E),r)}y[a]=h}return y}function We(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,o)=>{const[i,u,c,s]=e.map(f=>f.reduce((w,l)=>t.add(t.mul(w,r),l)));return r=t.div(i,u),o=t.mul(o,t.div(c,s)),{x:r,y:o}}}function Xe(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const i=Xt(r,2,{...e,DST:e.DST,...o}),u=t.fromAffine(n(i[0])),c=t.fromAffine(n(i[1])),s=u.add(c).clearCofactor();return s.assertValidity(),s},encodeToCurve(r,o){const i=Xt(r,1,{...e,DST:e.encodeDST,...o}),u=t.fromAffine(n(i[0])).clearCofactor();return u.assertValidity(),u}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Qe(t){return{hash:t,hmac:(n,...e)=>we(t,n,me(...e)),randomBytes:Ft}}function Je(t,n){const e=r=>Ke({...t,...Qe(r)});return Object.freeze({...e(n),create:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const St=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Et=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),fe=BigInt(1),pt=BigInt(2),Qt=(t,n)=>(t+n/pt)/n;function ae(t){const n=St,e=BigInt(3),r=BigInt(6),o=BigInt(11),i=BigInt(22),u=BigInt(23),c=BigInt(44),s=BigInt(88),f=t*t*t%n,w=f*f*t%n,l=j(w,e,n)*w%n,_=j(l,e,n)*w%n,v=j(_,pt,n)*f%n,y=j(v,o,n)*v%n,a=j(y,i,n)*y%n,h=j(a,c,n)*a%n,d=j(h,s,n)*h%n,m=j(d,c,n)*a%n,E=j(m,e,n)*w%n,x=j(E,u,n)*y%n,I=j(x,r,n)*f%n,p=j(I,pt,n);if(!ot.eql(ot.sqr(p),t))throw new Error("Cannot find square root");return p}const ot=$e(St,void 0,void 0,{sqrt:ae}),It=Je({a:BigInt(0),b:BigInt(7),Fp:ot,n:Et,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=Et,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-fe*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=e,u=BigInt("0x100000000000000000000000000000000"),c=Qt(i*t,n),s=Qt(-r*t,n);let f=Z(t-c*e-s*o,n),w=Z(-c*r-s*i,n);const l=f>u,_=w>u;if(l&&(f=n-f),_&&(w=n-w),f>u||w>u)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:f,k2neg:_,k2:w}}}},bt),_t=BigInt(0),ue=t=>typeof t=="bigint"&&_t<t&&t<St,Fe=t=>typeof t=="bigint"&&_t<t&&t<Et,Jt={};function Bt(t,...n){let e=Jt[t];if(e===void 0){const r=bt(Uint8Array.from(t,o=>o.charCodeAt(0)));e=Y(r,r),Jt[t]=e}return bt(Y(e,...n))}const Pt=t=>t.toRawBytes(!0).slice(1),$t=t=>rt(t,32),Nt=t=>Z(t,St),mt=t=>Z(t,Et),zt=It.ProjectivePoint,tn=(t,n,e)=>zt.BASE.multiplyAndAddUnsafe(t,n,e);function Ut(t){let n=It.utils.normPrivateKeyToScalar(t),e=zt.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:mt(-n),bytes:Pt(e)}}function le(t){if(!ue(t))throw new Error("bad x: need 0 < x < p");const n=Nt(t*t),e=Nt(n*t+BigInt(7));let r=ae(e);r%pt!==_t&&(r=Nt(-r));const o=new zt(t,r,fe);return o.assertValidity(),o}function de(...t){return mt(k(Bt("BIP0340/challenge",...t)))}function en(t){return Ut(t).bytes}function nn(t,n,e=Ft(32)){const r=V("message",t),{bytes:o,scalar:i}=Ut(n),u=V("auxRand",e,32),c=$t(i^k(Bt("BIP0340/aux",u))),s=Bt("BIP0340/nonce",c,o,r),f=mt(k(s));if(f===_t)throw new Error("sign failed: k is zero");const{bytes:w,scalar:l}=Ut(f),_=de(w,o,r),v=new Uint8Array(64);if(v.set(w,0),v.set($t(mt(l+_*i)),32),!he(v,r,o))throw new Error("sign: Invalid signature produced");return v}function he(t,n,e){const r=V("signature",t,64),o=V("message",n),i=V("publicKey",e,32);try{const u=le(k(i)),c=k(r.subarray(0,32));if(!ue(c))return!1;const s=k(r.subarray(32,64));if(!Fe(s))return!1;const f=de($t(c),Pt(u),o),w=tn(u,s,mt(-f));return!(!w||!w.hasEvenY()||w.toAffine().x!==c)}catch{return!1}}const fn=(()=>({getPublicKey:en,sign:nn,verify:he,utils:{randomPrivateKey:It.utils.randomPrivateKey,lift_x:le,pointToBytes:Pt,numberToBytesBE:rt,bytesToNumberBE:k,taggedHash:Bt,mod:Z}}))(),rn=(()=>We(ot,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))))(),on=(()=>Ye(ot,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ot.create(BigInt("-11"))}))(),ge=(()=>Xe(It.ProjectivePoint,t=>{const{x:n,y:e}=on(ot.create(t[0]));return rn(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ot.ORDER,m:1,k:128,expand:"xmd",hash:bt}))(),an=(()=>ge.hashToCurve)(),un=(()=>ge.encodeToCurve)();export{un as encodeToCurve,an as hashToCurve,fn as schnorr,It as secp256k1};
//# sourceMappingURL=secp256k1-8f9138ab.js.map
